<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta name="google-site-verification" content="8GGgPKpZ1TppYMoDv0s6xv83EPGR8NnwKao494_9b4U" />
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="msvalidate.01" content="8D562F5351236CEB3DC57C305A2440C3" />

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"punkli.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.1.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="总结C++11、C++14的学习笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="Modern C++ 学习笔记">
<meta property="og:url" content="https://punkli.github.io/2018/04.modern_cpp/index.html">
<meta property="og:site_name" content="skystarry">
<meta property="og:description" content="总结C++11、C++14的学习笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://punkli.github.io/img/share_ptr.png">
<meta property="article:published_time" content="2018-07-18T07:37:35.000Z">
<meta property="article:modified_time" content="2020-12-09T01:10:09.582Z">
<meta property="article:author" content="skystarry">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://punkli.github.io/img/share_ptr.png">


<link rel="canonical" href="https://punkli.github.io/2018/04.modern_cpp/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Modern C++ 学习笔记 | skystarry</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/rss_skystarry.xml" title="skystarry" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">skystarry</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%88%AB%E6%8E%A8%E5%AF%BC"><span class="nav-number">1.</span> <span class="nav-text">类别推导</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">1.1.</span> <span class="nav-text">模板类型推导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">1
2
3
4
template&lt;typename T&gt;void f(T&amp; Param);
f(x);  &#x2F;&#x2F; T: int        param: int&amp;
f(cx); &#x2F;&#x2F; T: const int  param: const int&amp;
f(rc); &#x2F;&#x2F; T: const int  param: const int&amp;
</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#-1"><span class="nav-number">1.3.</span> <span class="nav-text">1
2
3
4
5
template&lt;typename T&gt;void f(T&amp;&amp; Param);
f(x);  &#x2F;&#x2F; T: int&amp;        param: int&amp;
f(cx); &#x2F;&#x2F; T: const int&amp;  param: const int&amp;
f(rc); &#x2F;&#x2F; T: const int&amp;  param: const int&amp;
f(27); &#x2F;&#x2F; T: int         param: int&amp;&amp;
</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#-2"><span class="nav-number">1.4.</span> <span class="nav-text">1
const int* const ptr &#x3D; &amp;x;
</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#auto%E6%8E%A8%E5%AF%BC"><span class="nav-number">1.5.</span> <span class="nav-text">auto推导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decltype"><span class="nav-number">1.6.</span> <span class="nav-text">decltype</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E7%BB%93%E6%9E%9C"><span class="nav-number">1.7.</span> <span class="nav-text">类型推导结果</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#auto"><span class="nav-number">2.</span> <span class="nav-text">auto</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8auto"><span class="nav-number">2.1.</span> <span class="nav-text">使用auto</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">显式初始化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#modern-C"><span class="nav-number">3.</span> <span class="nav-text">modern C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%A4%A7%E6%8B%AC%E5%8F%B7"><span class="nav-number">3.1.</span> <span class="nav-text">关于大括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8nullptr"><span class="nav-number">3.2.</span> <span class="nav-text">使用nullptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8using%E4%BB%A3%E6%9B%BFtypedef"><span class="nav-number">3.3.</span> <span class="nav-text">使用using代替typedef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%AE%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="nav-number">3.4.</span> <span class="nav-text">限定作用域的枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">删除函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#override%E5%A3%B0%E6%98%8E"><span class="nav-number">3.6.</span> <span class="nav-text">override声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const-iterator"><span class="nav-number">3.7.</span> <span class="nav-text">const_iterator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#noexcept%E5%A3%B0%E6%98%8E"><span class="nav-number">3.8.</span> <span class="nav-text">noexcept声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8constexpr"><span class="nav-number">3.9.</span> <span class="nav-text">使用constexpr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">3.10.</span> <span class="nav-text">const成员函数的线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6"><span class="nav-number">3.11.</span> <span class="nav-text">成员函数的生成机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">4.</span> <span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#std-unique-ptr"><span class="nav-number">4.1.</span> <span class="nav-text">std::unique_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-shared-ptr"><span class="nav-number">4.2.</span> <span class="nav-text">std::shared_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-weak-ptr"><span class="nav-number">4.3.</span> <span class="nav-text">std::weak_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-make-unique%E5%92%8Cstd-make-shared"><span class="nav-number">4.4.</span> <span class="nav-text">std::make_unique和std::make_shared</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Pimpl%E4%B9%A0%E6%83%AF%E7%94%A8%E6%B3%95"><span class="nav-number">4.5.</span> <span class="nav-text">使用Pimpl习惯用法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-number">5.</span> <span class="nav-text">移动语义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#std-move%E5%92%8Cstd-forward"><span class="nav-number">5.1.</span> <span class="nav-text">std::move和std::forward</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">万能引用和右值引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%9E%E6%96%BDstd-move%EF%BC%8C%E5%AF%B9%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E5%AE%9E%E6%96%BDstd-forward"><span class="nav-number">5.3.</span> <span class="nav-text">对右值引用实施std::move，对万能引用实施std::forward</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">5.4.</span> <span class="nav-text">万能引用的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="nav-number">5.5.</span> <span class="nav-text">引用折叠</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%87%E5%AE%9A%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%B8%8D%E5%AD%98%E5%9C%A8%E3%80%81%E6%88%90%E6%9C%AC%E9%AB%98%E3%80%81%E6%9C%AA%E4%BD%BF%E7%94%A8"><span class="nav-number">5.6.</span> <span class="nav-text">假定移动操作不存在、成本高、未使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%9A%84%E5%A4%B1%E8%B4%A5%E6%83%85%E5%86%B5"><span class="nav-number">5.7.</span> <span class="nav-text">完美转发的失败情况</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%BB%98%E8%AE%A4%E6%8D%95%E8%8E%B7%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.</span> <span class="nav-text">避免默认捕获模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8D%95%E8%8E%B7%E5%B0%86%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%85%A5%E9%97%AD%E5%8C%85"><span class="nav-number">6.2.</span> <span class="nav-text">使用初始化捕获将对象移入闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9auto-amp-amp-%E5%BD%A2%E5%8F%82%E4%BD%BF%E7%94%A8dectltype"><span class="nav-number">6.3.</span> <span class="nav-text">对auto&amp;&amp;形参使用dectltype</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-bind"><span class="nav-number">6.4.</span> <span class="nav-text">std::bind</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91API"><span class="nav-number">7.</span> <span class="nav-text">并发API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.1.</span> <span class="nav-text">基于任务的程序设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%EF%BC%8C%E6%8C%87%E5%AE%9Astd-launch-async"><span class="nav-number">7.2.</span> <span class="nav-text">异步，指定std::launch::async</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BFstd-thread%E5%9C%A8%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E4%B8%8D%E5%8F%AF%E8%81%94%E7%BB%93"><span class="nav-number">7.3.</span> <span class="nav-text">使std::thread在所有路径不可联结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E6%B3%A8%E7%BA%BF%E7%A8%8B%E5%8F%A5%E6%9F%84%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">7.4.</span> <span class="nav-text">关注线程句柄的析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E4%B8%80%E6%AC%A1%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E4%BD%BF%E7%94%A8%E4%BB%A5void%E4%B8%BA%E6%A8%A1%E6%9D%BF"><span class="nav-number">7.5.</span> <span class="nav-text">针对一次性时间通信使用以void为模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91std-atomic%EF%BC%8C%E7%89%B9%E7%A7%8D%E5%86%85%E5%AD%98volatile"><span class="nav-number">7.6.</span> <span class="nav-text">并发std::atomic，特种内存volatile</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="skystarry"
      src="/img/skystarry.jpg">
  <p class="site-author-name" itemprop="name">skystarry</p>
  <div class="site-description" itemprop="description">Seek only light, freedom, and you.</div>
</div>

   <div class="feed-link motion-element">
     <a href="/rss_skystarry.xml" rel="alternate">
       <i class="fa fa-rss"></i>
       RSS
     </a>
   </div>
 
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9za3lzdGFycnkuZ2l0ZWUuaW8v" title="Wiki → https:&#x2F;&#x2F;skystarry.gitee.io&#x2F;">Wiki</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmxpY2h1bnBlbmcyMjAwQG91dGxvb2suY29t" title="E-Mail → mailto:lichunpeng2200@outlook.com">E-Mail</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9saS1jaHVucGVuZw==" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;li-chunpeng">知乎</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMTc5NDE2OTY1" title="B站 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;179416965">B站</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cDovL211c2ljLjE2My5jb20vIy91c2VyL2hvbWU/aWQ9MjcyMTA3MDQw" title="网抑云 → http:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;272107040">网抑云</span>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL1B1bmtMaQ==" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://punkli.github.io/2018/04.modern_cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/skystarry.jpg">
      <meta itemprop="name" content="skystarry">
      <meta itemprop="description" content="Seek only light, freedom, and you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="skystarry">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Modern C++ 学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-18 15:37:35" itemprop="dateCreated datePublished" datetime="2018-07-18T15:37:35+08:00">2018-07-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-09 09:10:09" itemprop="dateModified" datetime="2020-12-09T09:10:09+08:00">2020-12-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>31k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>28 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>总结C++11、C++14的学习笔记。<br><a id="more"></a> </p>
<h1 id="类别推导"><a href="#类别推导" class="headerlink" title="类别推导"></a>类别推导</h1><hr>
<p>C++98有用于函数模板的推导规则，C++11和C++14增加了用于auto和deltype的推导规则。</p>
<h2 id="模板类型推导"><a href="#模板类型推导" class="headerlink" title="模板类型推导"></a>模板类型推导</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType Param)</span></span>;</span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">f(expr);</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</span><br></pre></td></tr></table></figure>
<p>编译器会根据expr推导ParamType和T，两者有所差别。</p>
<p>情况1：ParamType是指针or引用<br>T的推导结果会忽略expr的指针or引用，其他类型修饰如<code>const</code>会被保留。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; Param)</span></span>;</span><br><span class="line">f(x);  <span class="comment">// T: int        param: int&amp;</span></span><br><span class="line">f(cx); <span class="comment">// T: const int  param: const int&amp;</span></span><br><span class="line">f(rc); <span class="comment">// T: const int  param: const int&amp;</span></span><br></pre></td></tr></table></figure></h2><p>情况2：ParamType是万能引用<br>如果expr是左值，T和Param都会被推导为<code>左值引用</code>(唯一情况)。<br>如果expr是右值，和<code>情况1</code>相同。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; Param)</span></span>;</span><br><span class="line">f(x);  <span class="comment">// T: int&amp;        param: int&amp;</span></span><br><span class="line">f(cx); <span class="comment">// T: const int&amp;  param: const int&amp;</span></span><br><span class="line">f(rc); <span class="comment">// T: const int&amp;  param: const int&amp;</span></span><br><span class="line">f(<span class="number">27</span>); <span class="comment">// T: int         param: int&amp;&amp;</span></span><br></pre></td></tr></table></figure></h2><p>情况3：按值传递<br>param是一个全新的对象。引用、const、volatile性质都会忽略。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T Param)</span></span>;</span><br><span class="line">f(x);  <span class="comment">// T: int  param: int</span></span><br><span class="line">f(cx); <span class="comment">// T: int  param: int</span></span><br><span class="line">f(rc); <span class="comment">// T: int  param: int</span></span><br></pre></td></tr></table></figure><br>考虑一个特殊情况，const指针在传递中，自身const会被忽略，指向的对象const会被保留。</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> ptr = &amp;x;</span><br></pre></td></tr></table></figure></h2><p>情况4：数组实参与函数实参<br>数组指针在传参过程中会退化成指向数组首元素的指针，可以通过把形参声明成数组的引用，得到实际的数组类别。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> keyVals[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize(keyVals)&gt; mappedVals;</span><br></pre></td></tr></table></figure><br>函数类型也会退化成指针。处理方式和上面一样。</p>
<h2 id="auto推导"><a href="#auto推导" class="headerlink" title="auto推导"></a>auto推导</h2><p>首先，auto处理数组实参与函数实参也会退化。<br>其次，auto在初始化时，如果表达式是<code>&#123;&#125;</code>括起来的，会按照<code>std::initializer_list&lt;T&gt;</code>推导，如果<code>T</code>推导失败，模板推导也会失败。<br>在函数返回值使用<code>auto</code>，不会推导<code>std::initializer_list&lt;T&gt;</code>而是常规的模板推导。</p>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p><code>decltype</code>主要用在声明那些返回值依赖形参类型的函数。<br>C++14允许对一切<code>lambda式</code>和一切函数进行推导，不过会有隐患，所以需要<code>decltype</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="keyword">auto</span> </span><br><span class="line">authAndAccess(Container&amp;&amp; c, Index i)</span><br><span class="line">-&gt; <span class="keyword">decltype</span>(<span class="built_in">std</span>::forward&lt;Container&gt;(c)[i])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>decltype(x)</code>结果为<code>int</code>，<code>decltype((x))</code>结果为<code>int&amp;</code>，小心<code>decltype(auto)</code>，为了保证推导完全没有隐患，可以看第四节。</p>
<h2 id="类型推导结果"><a href="#类型推导结果" class="headerlink" title="类型推导结果"></a>类型推导结果</h2><p>这算是奇技淫巧吧，通过编译器诊断信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">TD</span>;</span>  <span class="comment">// 只声明</span></span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(x)&gt; xType;         <span class="comment">// 诱发编译器产生类型错误</span></span><br></pre></td></tr></table></figure><br>运行时输出类型，涉及到<code>std::type_info::name</code>，不保证输出任何有意义的内容。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(x).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><br><code>std::type_info::name</code>处理类型的方式类似于函数模板按值传递，因此得到的类型可能不准确。<br><code>Boost.TypeIndex</code>可以产生精确的类型信息，函数模板<code>boost::typeindex::type_id_with_cvr</code>接受一个类型实参，而且不会移除<code>const</code>、<code>volatile</code>和引用，返回一个<code>boost::typeindex::type_index</code>对象，最后调用<code>pretty_name()</code>。</p>
<h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><hr>
<h2 id="使用auto"><a href="#使用auto" class="headerlink" title="使用auto"></a>使用auto</h2><ol>
<li>使用<code>std::function</code>声明、储存一个闭包的变量是<code>std::function</code>的一个实例，占有固定内存，空间不够的时候会分配堆上内存。</li>
<li>使用<code>auto</code>声明、储存一个闭包的变量和该闭包是一个类型，要求的内存一样。比<code>std::function</code>更优。</li>
<li>像<code>std::vector&lt;int&gt;::size_type</code>这样的类型跟平台有关，建议<code>auto</code></li>
<li>像<code>std::unordered_map&lt;const std::string, int&gt;</code>这样的类型，显式指定容易引起不想要的类型转换，建议<code>auto</code></li>
</ol>
<h2 id="显式初始化"><a href="#显式初始化" class="headerlink" title="显式初始化"></a>显式初始化</h2><p><code>auto</code>的结果不能总是满足期望，会有意外。<br><strong>例子：</strong><br><code>std::vector&lt;bool&gt;</code>对象执行<code>std::vector::operator[]</code>后，返回<code>std::vector&lt;bool&gt;::reference</code>类型，这是嵌套在<code>std::vector&lt;bool&gt;</code>里的类，然后做了一个向<code>bool</code>的隐式转换。<br><strong>原理：</strong><br>因为过特化，<code>bool</code>被压缩形式表示，<code>std::vector::operator[]</code>返回<code>T&amp;</code>，但是C++不允许比特引用。<br><code>std::vector&lt;bool&gt;::reference</code>要保证能用到<code>bool&amp;</code>的地方它也能用，所以做了一个向<code>bool</code>的隐式转换，但不是<code>bool&amp;</code>。<br><strong>意外：</strong><br>使用auto会导致容器元素被推导成<code>std::vector&lt;bool&gt;::reference</code>，这样再使用下标<code>[]</code>就是返回第几个比特，而不是第几个元素。<br><strong>后果：</strong><br><code>std::vector&lt;bool&gt;::reference</code>对象的一种实现是含有一个指针，指向一个机器字，该Word有那个被引用的比特，再加上基于那个比特对应的字的偏移量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(w, highPriority); <span class="comment">// Error, highPriority含有悬空指针</span></span><br></pre></td></tr></table></figure><br>“隐形”代理类（还有表达式模板）和<code>auto</code>无法和谐相处，这种类的对象往往会设计成仅仅维持到单个语句之内存在。<br>使用显式的强制转换，得到想要的类型，避开代理类的暗坑。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(feature(w)[<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">auto</span> sum = <span class="keyword">static_cast</span>&lt;Matrix&gt;(m1+m2+m3+m4);</span><br></pre></td></tr></table></figure></p>
<h1 id="modern-C"><a href="#modern-C" class="headerlink" title="modern C++"></a>modern C++</h1><hr>
<h2 id="关于大括号"><a href="#关于大括号" class="headerlink" title="关于大括号"></a>关于大括号</h2><ol>
<li>大括号禁止内建类型之间进行隐式窄化转换。</li>
<li>C++任何能够解析为声明的都会解析为声明，用<code>&#123;&#125;</code>调用默认构造函数初始化对象可以避免被当成函数声明。</li>
<li>在构造函数被调用时，形参中没有<code>std::initialier_list</code>，那么大小括号没有区别；如果有，则<code>&#123;&#125;</code>会优先使用带<code>std::initialier_list</code>的构造函数。</li>
<li>空的大括号表示“没有实参”，而不是空的<code>std::initialier_list</code>。如果要调用一个带有<code>std::initialier_list</code>的构造函数，并且传入一个空的<code>std::initialier_list</code>，可以这样写:<code>&#123; &#123; &#125; &#125;</code>。</li>
<li>在设计构造函数的时候，<code>std::vector</code>是个反例，不要学它。</li>
<li>更具有弹性的设计，允许调用者自行决定使用大括号还是小括号，<span class="exturl" data-url="aHR0cHM6Ly9ha3J6ZW1pMS53b3JkcHJlc3MuY29tLzIwMTMvMDYvMDUvaW50dWl0aXZlLWludGVyZmFjZS1wYXJ0LWkv">Intuitive interface, Andrzej<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<h2 id="使用nullptr"><a href="#使用nullptr" class="headerlink" title="使用nullptr"></a>使用nullptr</h2><ol>
<li><code>0</code>和<code>NULL</code>都不具备指针的类别，在指针型和整型之间进行重载时容易发生意外。</li>
<li><code>nullptr</code>的实际类型的<code>std::nullptr_t</code>，而<code>std::nullptrd</code>的类型被指定为<code>nullptr</code>，<code>nulllptr</code>可以隐式转换到所有的裸指针上。</li>
</ol>
<p>将nullptr用于模板，适当的互斥量锁定，调用，解锁<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FuncType,</span><br><span class="line">         <span class="keyword">typename</span> MuxType,</span><br><span class="line">         <span class="keyword">typename</span> PtrType&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">lockAndCall</span><span class="params">(FuncType func,</span></span></span><br><span class="line"><span class="function"><span class="params">                 MuxType&amp; mutex,</span></span></span><br><span class="line">                 PtrType ptr) -&gt; decltype(func(ptr))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> func(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">auto</span> result = lockAndCall(f,fm,<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="使用using代替typedef"><a href="#使用using代替typedef" class="headerlink" title="使用using代替typedef"></a>使用using代替typedef</h2><ol>
<li><code>typedef</code>不支持模板化，但别名声明支持。</li>
<li>别名模板可以免写<code>::type</code>后缀，在模板内，对于内嵌<code>typedef</code>的引用经常要加上<code>typename</code>前缀。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="keyword">using</span> FP = <span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在处理模板时</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">MyAllocList</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">MyAllocList&lt;Widget&gt; lw;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板内使用typedef</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> MyAllocList&lt;T&gt;::type <span class="built_in">list</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    MyAllocList&lt;T&gt; <span class="built_in">list</span>;          <span class="comment">// 使用了using</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对编译器来讲，<code>MyAllocList&lt;T&gt;</code>别名模板命名了一个类型，是非依赖性的，所以<code>typename</code>不要求也不允许。而<code>MyAllocList&lt;Widget&gt;::type</code>不能确定是否是一个类型，在某个特化中，代表并非类型而是其他什么的东西，所以要加<code>typename</code>。</p>
<p>Note:从模板类型形参出发创建其修正类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="comment">//c++11</span></span><br><span class="line"><span class="built_in">std</span>::remove_const&lt;T&gt;::type</span><br><span class="line"><span class="built_in">std</span>::remoeve_reference&lt;T&gt;::type</span><br><span class="line"><span class="built_in">std</span>::add_lvalue_reference&lt;T&gt;::type</span><br><span class="line"><span class="comment">//c++14</span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">remove_const_t</span>&lt;T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">remoeve_reference_t</span>&lt;T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">add_lvalue_reference_t</span>&lt;T&gt;</span><br><span class="line"><span class="comment">// using</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">remove_const_t</span> = <span class="built_in">std</span>::remove_const&lt;T&gt;::type;</span><br></pre></td></tr></table></figure></p>
<h2 id="限定作用域的枚举"><a href="#限定作用域的枚举" class="headerlink" title="限定作用域的枚举"></a>限定作用域的枚举</h2><p>关于C++98的枚举：</p>
<ol>
<li>容易造成命名空间的污染。</li>
<li>可以隐式转换到<code>int</code>，甚至可以进一步转换到<code>float</code>，算个隐患。</li>
<li>不能前置声明（在C++11中可以了），增加了编译依赖性。</li>
<li>为了节约使用内存，编译器通常会为枚举分配刚好够用的最小底层类型。</li>
</ol>
<p>关于C++11的枚举：</p>
<ol>
<li>通过<code>enum class</code>声明，枚举类。</li>
<li>枚举类型更强，不允许隐式转换。</li>
<li>可以前置声明了，而且可以指定枚举的底层类型，比如<code>enum class Color: std::uint8_t;</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo = <span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;;</span><br><span class="line"><span class="comment">// 使用限定作用域的枚举，缺点是需要强制转换</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">userInfoFields</span> &#123;</span>uiName, uiEmail, uiReputation &#125;;</span><br><span class="line">UserInfo uInfo;</span><br><span class="line"><span class="keyword">auto</span> val = </span><br><span class="line"><span class="built_in">std</span>::get&lt;<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;(uInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用std::underly_type得到枚举的底层类型，type_traits</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> <span class="built_in">std</span>::underly_type&lt;E&gt;::type</span><br><span class="line">    toUType(E enumerator) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span></span><br><span class="line">           <span class="built_in">std</span>::underlying_type&lt;E&gt;::type&gt;(enumerator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用函数代替强制转换</span></span><br><span class="line"><span class="built_in">std</span>::get&lt;toUType(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure>
<h2 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h2><ol>
<li>声明<code>private</code>函数，用<code>delete</code>代替，无法通过任何方式访问。</li>
<li>任何函数都能成为删除函数，在函数重载中可以避免不想要的重载，在函数模板中，可以避免不想要的具体化。</li>
<li>模板特化必须在命名空间作用域，在类作用于不允许。因此，类内部的函数模板不想要的特化用<code>delete</code>。</li>
</ol>
<h2 id="override声明"><a href="#override声明" class="headerlink" title="override声明"></a>override声明</h2><p>在派生类声明一个函数，意在重写基类虚函数时，加上<code>override</code>声明。<br>C++对重写有严格要求，很容易就声明了一个新函数：</p>
<ol>
<li>基类的函数必须是虚函数。</li>
<li>函数名字必须完全一样（析构函数除外）。</li>
<li>形参类型必须完全一样</li>
<li>函数的后缀性质完全一样。</li>
<li>函数返回值和一场规格必须兼容。</li>
</ol>
<p>C++11新增成员函数引用特性，为了给<code>*this</code>加一些区分度，原理同<code>const</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line">    <span class="function">DataType&amp; <span class="title">data</span><span class="params">()</span> &amp; </span>&#123;<span class="keyword">return</span> values;&#125;</span><br><span class="line">    <span class="function">DataType <span class="title">data</span><span class="params">()</span> &amp;&amp; </span>&#123;<span class="keyword">return</span> <span class="built_in">std</span>::move(values);&#125; <span class="comment">// 移动语义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="const-iterator"><a href="#const-iterator" class="headerlink" title="const_iterator"></a>const_iterator</h2><p>在C++98中，很难从一个<code>非const</code>容器得到对应的<code>const</code>容器，插入删除只能以<code>iterator</code>指定，而不接受<code>const_iterator</code>。从<code>const_iterator</code>到<code>iterator</code>不存在可移植的类型转换。C++11解决了这些问题，并且指示位置的迭代器都更换成了<code>const_iterator</code>。<br>写最通用化的库代码，需要考虑以非成员函数提供接口的情况，对于非成员函数版本的支持：</p>
<ol>
<li><code>begin</code>、<code>end</code> (c++11)</li>
<li><code>cbegin</code>、<code>cend</code>、<code>rbegin</code>、<code>rend</code>、<code>crbegin</code>、<code>crend</code> (c++14)</li>
</ol>
<p>写一个<code>cbegin</code>的实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>&gt;</span></span><br><span class="line">auto cbegin(const C&amp; container)-&gt;decltype(std::begin(container))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::begin(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里通过<code>const引用</code>类型产生一个类似<code>const_iterator</code>的效果。</p>
<h2 id="noexcept声明"><a href="#noexcept声明" class="headerlink" title="noexcept声明"></a>noexcept声明</h2><p>如果函数f运行期出发了异常，<br>C++98：调用栈会开解到f的调用者，然后执行一些瞎操作，程序执行终止。<br>C++11：程序终止之前，栈只是<code>可能会</code>开解。<br>在带有<code>noexcept</code>声明的函数中，优化器不需要将执行期栈保持在可以开解的状态，也不需要在异常溢出的前提下，保证里面的对象按照构造顺序逆序析构。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReType <span class="title">func</span><span class="params">(params)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 最优化</span></span><br><span class="line"><span class="function">ReType <span class="title">func</span><span class="params">(params)</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">// 优化不够</span></span><br></pre></td></tr></table></figure><br>std::vector的push_back操作是异常安全保证的（遗留代码会依赖这样的特性），<code>std::vector::push_back</code>调用<code>std::move_if_noexcept</code>，接着向<code>std::is_nothrow_move_constructible</code>（模板特征）求助。<br>类似这样的接口都使用“能移动则移动，必须复制才复制”的策略，也就是<code>push_back</code>是否<code>noexcept</code>取决于push对象的移动构造函数是否是<code>noexcept</code>的。<br>另一个例子是<code>swap</code>，这些函数带有条件式的<code>noexcept</code>声明，高阶数据结构的<code>swap</code>行为要依赖低阶数据结构的<code>swap</code>行为，以此类推。</p>
<p>大多数函数都是异常中立的，自身不抛出异常，但内部调用的函数可能会发生异常，发生异常时，会允许异常经由它传递到调用栈更深的一层，就像路过一样。不具备<code>noexcept</code>。</p>
<p>C++98：允许内存释放函数（operator、delete、析构）触发异常，允许但是糟糕。<br>C++11：默认所有的内存释放函数和析构函数都是<code>noexcept</code>，除非显式声明<code>noexcept(false)</code>。</p>
<p>宽约束函数：没有调用的限制条件，也不会出现未定义行为。<br>窄约束函数：对调用有条件限制，就能异常。</p>
<h2 id="使用constexpr"><a href="#使用constexpr" class="headerlink" title="使用constexpr"></a>使用constexpr</h2><p><code>constexpr</code>是对象和函数接口的组成部分，<code>constexpr</code>对象比<code>const</code>对象更“常量”，符合编译期常量的语境。<br><code>constexpr</code>函数在调用时若传入的是编译器常量，则返回的也是常量，如果传入的是直到运行期才知晓的值，就和普通函数一样，但如果所有实参都在编译期未知，那么代码无法通过编译。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="built_in">pow</span>(3,num)&gt; result;</span><br></pre></td></tr></table></figure><br>在C++11中，<code>constexpr</code>函数不得包含多于一个可执行语句，C++14解除了限制。<br><code>constexpr</code>可以让更多运行期进行的工作在编译期完成。</p>
<h2 id="const成员函数的线程安全"><a href="#const成员函数的线程安全" class="headerlink" title="const成员函数的线程安全"></a>const成员函数的线程安全</h2><p>对于单个要求同步的变量或内存区域，使用<code>std::atomic</code>就足够了。如果有更多的内存区域需要同步，就要使用<code>std::mutex</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>; <span class="comment">// 加上互斥量</span></span><br><span class="line">    	<span class="keyword">if</span> (!rootsAreValid)</span><br><span class="line">    	&#123;</span><br><span class="line">    		rootsAreValid = <span class="literal">true</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> rootVals;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> rootsAreValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="成员函数的生成机制"><a href="#成员函数的生成机制" class="headerlink" title="成员函数的生成机制"></a>成员函数的生成机制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(Widget&amp;&amp; rhs);            <span class="comment">// 移动构造</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs); <span class="comment">// 移动赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于移动操作：</p>
<ol>
<li>移动操作和复制操作一样，仅作用于非静态成员，同时也会相应地构造/赋值基类部分。</li>
<li>移动操作不一定真的成功，而是一种请求。对于不可移动得类型，会按照复制操作实现“移动”。</li>
<li>移动操作的核心在于把<code>std::move</code>应用于每个对象，其返回值被用于函数重载，最终决定执行移动还是复制。</li>
</ol>
<p>两种复制操作彼此独立：</p>
<ol>
<li>声明了一个，并不会阻止编译器生成另一个。</li>
<li>一旦显式声明了移动操作，编译器就会废除复制操作，通过<code>=delete</code>。</li>
</ol>
<p>两种移动操作不独立：</p>
<ol>
<li>声明了其中一个，编译器就不会生成另一个。因为只要声明了移动操作，就表示移动操作的实现方式会和编译器默认生成的行为多少有些不同。</li>
<li>一旦显式声明了复制操作，这个类也不会默认生成移动操作了，理由同上。</li>
</ol>
<p>大三律原则：</p>
<ol>
<li>如果有改写复制操作的需求，往往意味着该类需要执行某种资源管理。默认生成的操作不适用，而且需要正确的析构。</li>
<li>标准库中用以管理内存的类都会遵从原则。</li>
<li>声明了析构函数，那么默认生成的复制可能不适用，或者说此时复制操作就不该默认生成，但是从C++98到C++11，保留了这一特性。</li>
<li>只要声明了析构函数，就不会生成移动操作。</li>
</ol>
<p>移动操作生成的条件：该类没有任何复制/移动/析构操作。这些标准可以延伸到复制操作上，在已经存在复制/析构条件下，仍然自动生成复制操作已经成为被废弃的特性，在代码中应该尽可能消除这样的依赖。<br>C++11可以通过<code>=default</code>来显式表达这个想法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Widget(); </span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这种写法在多态基类中常见。<br>一旦声明了析构函数，移动操作的生成就会被抑制，加上<code>=default</code>能够再给编译器一次机会，声明移动又会废除复制，可以再加一轮<code>=default</code>。这个没啥用，但是啥都不写可能一不注意就引发性能问题。</p>
<p>函数模板不会影响到成员函数的生成。</p>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><hr>
<h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p><code>std::unique_ptr</code>和裸指针拥有相同的尺寸，只能移动不能复制，移动一个std::unique_ptr会移动所有权，原指针自动挂空。执行析构时，由非空的<code>std::unique-ptr</code>内部的裸指针完成。<br><code>std::unique_ptr</code>随对象主体的析构而被析构，如果是异常或非典型流程，最终调用该资源的析构函数析构。析构默认通过delete，也可以自定义析构器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义析构器</span></span><br><span class="line"><span class="keyword">auto</span> delInvmt = [](Investment* pInvestment)</span><br><span class="line">                &#123;</span><br><span class="line">                    makeLogEntry(pInvestment); <span class="comment">// 删除前先写入日志</span></span><br><span class="line">                    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">                &#125;;</span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment, <span class="keyword">decltype</span>(delInvmt)&gt;</span><br><span class="line">makeInvestment(Ts&amp;... params)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment, <span class="keyword">decltype</span>(delInvmt)&gt;</span><br><span class="line">        pInv(<span class="literal">nullptr</span>, delInvmt);</span><br><span class="line">    <span class="comment">// 一些创建对象的操作</span></span><br><span class="line">    pInv.reset(<span class="keyword">new</span> something(<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">auto</span> pInvestment = makeInvestment(arguments); <span class="comment">// std::unique_ptr指针</span></span><br></pre></td></tr></table></figure><br>将一个裸指针赋给<code>std::unique_ptr</code>不会编译通过，因为裸指针到智能指针的隐式类型转换有问题，所以需要<code>reset</code>。在C++14中，自定义析构器可以定义在<code>makeInvestment</code>内部了。<br>对于自定义析构器：</p>
<ol>
<li>指定为<code>std::unique_ptr</code>的第二个实参。</li>
<li>接受Investment*的形参最后删除，等价于通过一个基类指针删除派生类对象，因此<code>Investment</code>要有虚析构函数。</li>
<li>若析构器为函数指针，则<code>std::unique_ptr</code>长度一般会增长一到两个字长。</li>
<li>若析构器为函数对象，则<code>std::unique_ptr</code>长度增长取决于函数对象中储存了多少状态。</li>
<li>无捕获的lambda表达式属于无状态的函数对象。</li>
</ol>
<p><code>std::unique_ptr</code>区分<code>std::unique_ptr&lt;T&gt;</code>和<code>std::unique_ptr&lt;T[]&gt;</code>，这种区分对指向的对象类型没有二义性。对单个对象没有<code>operator[]</code>，对数组形式没有<code>opeartor*</code>和<code>operator-&gt;</code>。</p>
<p><code>std::unique_ptr</code>可以很轻松转换成<code>std::shared_ptr</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; sp = makeInvestment(arguments);</span><br></pre></td></tr></table></figure></p>
<h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p><code>std::shared_ptr</code>可以通过访问某资源的引用计数来确定自己是否是最后一个指针，例如<code>sp1 = sp2</code>代表<code>sp2</code>引用计数递增，而<code>sp1</code>引用计数递减，递减为零就会释放。</p>
<ol>
<li><code>std::shared_ptr</code>尺寸是裸指针的两倍（指针资源的裸指针+指向引用计数的裸指针）</li>
<li>引用计数与资源关联，但是不知道对象是谁（内建类型也可以用<code>std::shared_ptr</code>）。需要动态分配，若由<code>std::make_ptr</code>分配，可以避免动态分配的成本。</li>
<li>引用计数的递增递减必须是原子操作，因为可能会有并发读写。</li>
<li>移动操作会把原指针置空，当前新指针不需要计数。只有复制操作会增加引用计数。</li>
<li>支持自定义析构器，但不是类型的一部分，析构器不同会影响<code>std::unique_ptr</code>但不会影响<code>std::shared_ptr</code>。</li>
<li><code>std::shared_ptr</code>的尺寸不会受到自定义析构器的影响。</li>
</ol>
<p>析构器可能是函数对象有更多数据，这时<code>std::shared_ptr</code>不得不使用更多内存，但这并不属于自身的一部分，而是把这些内存放在堆上。每个由<code>std::shared_ptr</code>管理的对象都有一个控制块。</p>
<p><img src="/img/share_ptr.png" alt="std::shared_ptr指针的内存示意图">在控制块上，如果自定义析构器被指定，就会包含一份它的复制。如果自定义内存分配器被指定，也会有一份复制。还包括很多附加数据。<br>控制块中的引用计数会跟踪有多少个<code>std::shared_ptr</code>指向该控制块，控制块还包含第二个引用计数，对<code>std::weak_ptr</code>进行计数（弱计数）。<code>std::weak_ptr</code>通过检查控制块内的引用计数来校验自己是否失效，假设引用计数为0，没有<code>std::shared_ptr</code>指向对象，对象已经被析构，则<code>std::weak_ptr</code>会失效，如果是使用<code>std::make_shared</code>创建的内存块，此时<code>std::shared_ptr</code>已经析构，但是<code>std::weak_ptr</code>依然存在并会指向到控制块（弱计数大于零），所以控制块会持续存在，包含它的内存也会持续存在。</p>
<p>一般情况，对象的控制块由首个创建指向它的<code>std::shared_ptr</code>的函数来确定。但是正在创建指向某对象的<code>std::shared_ptr</code>的函数是不知道是否由其他的<code>std::shared_ptr</code>已经指向了该对象的。因此：</p>
<ol>
<li><code>std::make_shared</code>总是创建一个控制块。</li>
<li>从<code>std::unique_ptr</code>或<code>std::auto_ptr</code>出发构造<code>std::shared_ptr</code>时，会创建一个控制块。</li>
<li>当<code>std::shared_ptr</code>构造函数使用裸指针作为实参来调用时，会创建一个控制块。</li>
<li>如果从已经有控制块的对象出发，传入<code>std::shared_ptr</code>或者<code>std::weak_ptr</code>就不会创建新的控制块。</li>
</ol>
<p>从同一个裸指针出发构造不止一个<code>std::shared_ptr</code>就会多重的控制块，多重的引用计数，也会多重的析构，Boom~！<br>但是可以这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>; <span class="comment">// 直接new</span></span><br><span class="line"><span class="comment">// 容易出现上面错误的时this指针，例如：</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;&gt; processWidgets;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::procsee</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    processWidgets.emplace_back(<span class="keyword">this</span>); </span><br><span class="line">    <span class="comment">// this是裸指针，传入`std::shared_ptr`容器会创建内存块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不过也有解决方法：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE1JTg3JUU1JUJDJTgyJUU5JTgwJTkyJUU1JUJEJTkyJUU2JUE4JUExJUU2JTlEJUJGJUU2JUE4JUExJUU1JUJDJThG">The Curiously Recurring Template Pattern<i class="fa fa-external-link-alt"></i></span><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_form_this&lt;Widget&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        processWidgets.emplace_back(shared_form_this()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>std::enable_shared_form_this&lt;T&gt;</code>是一个基类，它有一个成员函数是<code>shared_form_this()</code>会从this创建一个<code>std::shared_ptr</code>，这样的设计依赖于当前对象已有一个关联的<code>std::shared_ptr</code>控制块，否则该行为未定义，通常会<code>shared_form_this()</code>抛出异常。<br>为了解决这个顺序问题，继承自<code>std::enable_shared_form_this&lt;T&gt;</code>的类可以把构造函数声明为私有，只允许通过工厂函数创建对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_form_this&lt;Widget&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">create</span><span class="params">(Ts&amp;&amp;... params)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一个控制块通常只有几个字节，但自定义析构器和内存分配器可能会使其变得更大。控制块的实现原理涉及到继承，甚至还会有虚函数（仅在析构的时候使用一次），而进行一项引用计数需要一个或两个原子化操作，映射到单个机器指令，这些都是<code>std::shared_ptr</code>性能上的成本。<br>在使用一切默认+<code>std::shared_ptr</code>和<code>std::make_shared</code>时，控制块就三个字长，分配操作零成本。这就是C++动态分配资源，自动生存期管理的温和成本。<br>最后，不存在<code>std::shared_ptr&lt;T[]&gt;</code>，这和<code>std::unique_ptr</code>不同。</p>
<h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p><code>std::weak_ptr</code>并不是一种独立的智能指针，而是<code>std::shared_ptr</code>的扩充。它可以像<code>std::shared_ptr</code>一样运作，同时不影响其指向对象的引用计数，而且要能跟踪指针何时悬空。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = <span class="built_in">std</span>::make_shared&lt;Widget&gt;(); <span class="comment">// spw构造完成，Widget引用计数为1</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;Widget&gt; <span class="title">wpw</span><span class="params">(spw)</span></span>;        <span class="comment">// wpw和spw指向同一个widget，引用计数保持为1</span></span><br><span class="line">spw = <span class="literal">nullptr</span>;                         <span class="comment">// 引用计数0，widget被析构，wpw悬空</span></span><br></pre></td></tr></table></figure><br>关于<code>std::weak_ptr</code>的使用场景</p>
<ol>
<li><code>std::weak_ptr</code>是否失效的校验（为了线程安全需要原子操作），以及在未失效的条件下提供所指涉到的对象的访问<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw1 = wpw.lock(); <span class="comment">// 若wpw失效，则spw为空</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw2</span><span class="params">(wpw)</span></span>;         <span class="comment">// 若wpw失效，抛出std::bad_weak_ptr异常</span></span><br></pre></td></tr></table></figure></li>
<li>带缓存的工厂函数，缓存管理器<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> Widget&gt; <span class="title">fastLoadWidget</span><span class="params">(WidgetID id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// C++11散列表容器，缓存</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::unorderd_map&lt;WidgetID, <span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">const</span> Widget&gt;&gt; cache;</span><br><span class="line">    <span class="keyword">auto</span> objPtr = cache[id].lock(); <span class="comment">// 如果对象不在缓存中，返回空指针</span></span><br><span class="line">    <span class="keyword">if</span>(!objPtr)&#123;</span><br><span class="line">        objPtr = loadWidget(id);    <span class="comment">// 加载</span></span><br><span class="line">        cache[id] = objPtr;         <span class="comment">// 缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objPtr; <span class="comment">// 缓存中失效的std::weak_ptr会不断积累，可以优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>观察者模式——可以改变状态的对象，观察者（对象状态发生改变后通知的对象）。</li>
<li>避免<code>std::shared_ptr</code>的指针环路，如果A和B相互指向对方，这种环路会阻止析构，资源得不到回收。</li>
</ol>
<p>最后，<code>std::weak_ptr</code>和<code>std::shared_ptr</code>对象尺寸相同，也使用同样的控制块。</p>
<h2 id="std-make-unique和std-make-shared"><a href="#std-make-unique和std-make-shared" class="headerlink" title="std::make_unique和std::make_shared"></a>std::make_unique和std::make_shared</h2><p><code>std::make_shared</code>来自C++11，<code>std::make_unique</code>来自C++14，不过可以用C++11简易实现，参考<span class="exturl" data-url="aHR0cHM6Ly9pc29jcHAub3JnL2Jsb2cvMjAxMy8wNC9uMzY1Ni1tYWtlLXVuaXF1ZS1yZXZpc2lvbi0x">创建make_unique, N3656, Stephan T.Lavavej, 2013-4-18<i class="fa fa-external-link-alt"></i></span><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个简易实现不支持数组和自定义析构器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">make_unique</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>make系列函数会把一个任意实参集合完美转发给动态分配内存对象的构造函数，并返回一个指向该对象的智能指针，分别是<code>std::make_unique</code>、<code>std::make_shared</code>、<code>std::allocate_shared</code>（动态分配器）。</p>
<p>优先使用make的原因之一与异常安全有关，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw, <span class="keyword">int</span> priority)</span></span>;</span><br><span class="line">processWidget(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), computePriority()); <span class="comment">// 潜在的资源泄露</span></span><br><span class="line">processWidget(<span class="built_in">std</span>::make_shared&lt;Widget&gt;(), computePriority()); <span class="comment">// 安全</span></span><br></pre></td></tr></table></figure><br>这里的风险来自编译器从源代码到目标代码的翻译过程，在运行时，传递给函数的实参必须在函数调用被发起之前完成评估求值。因此在这里：</p>
<ol>
<li>表达式<code>new Widget</code>必须完成评估求值，在堆上创建</li>
<li>由new产生的裸指针的托管对象<code>std::shared_ptr&lt;Widget&gt;</code>的构造函数必须执行。</li>
<li><code>computeProprity()</code>必须运行</li>
</ol>
<p>但是编译器不必要按照这个顺序生成代码，最糟糕的情况是先运行new后运行<code>computeProprity</code>最后运行<code>std::shared_ptr</code>构造函数，这样如果<code>computeProprity</code>产生异常，第一步创建的new永远不会被储存到第三步才接管的<code>std::shared_ptr</code>，但是使用<code>std::make_shared</code>就没有这个问题。</p>
<p>优先使用make的原因之二是性能提升<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;   <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">auto</span> spw = <span class="built_in">std</span>::make_shared_ptr&lt;Widget&gt;(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><br>情况1会多一次内存分配，第一次分配是new分配，第二次是<code>std::share_ptr</code>的构造函数对控制块的分配。<br>情况2只有1次内存分配，对象+控制块，会分配在一个同一块内存上（单块内存）。</p>
<p>但是make函数有许多限制：</p>
<ol>
<li>不允许使用自定义析构器，只能用构造函数实现。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> widgetDeleter = [](Wiget* pw)&#123;...&#125;;</span><br><span class="line">std::unique_ptr&lt;Widget, decltype(widgetDeleter)&gt; upw(new Widget, widgetDleter);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, widgetDeleter)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>make函数对形参进行完美转发使用的是圆括号，大括号会优先匹配<code>std::initializer_list</code>类型的构造函数，因此假如要使用大括号初始化就必须使用new了。不能够完美转发大括号初始化物，但是可以尝试auto推导创建一个<code>std::initializer_list</code>对象。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> initList = &#123;<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> spv = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(initList);</span><br></pre></td></tr></table></figure>
对<code>std::unique</code>而言，仅在上面两种情景下会存在问题。而对<code>std::shared_ptr</code>和其他make函数而言，还有其他两种更边缘的场景：</li>
<li>有些类会定义自身版本的<code>operator new</code>和<code>operator delete</code>，全局版本的内存分配策略不适用于这些类。通常，类自定义的这两种函数被设计成仅用来分配和是犯法该类精确尺寸的内存块，就不适于用<code>std::shared_ptr</code>所用的自定义分配器（通过<code>std::allocate_shared</code>）和自定义析构器了。因为<code>std::allocate_shared</code>所需要的内存并不等于动态分配对象的尺寸，所以这种情况推荐new。</li>
<li>使用<code>std::make_shared</code>创建的内存块，此时<code>std::shared_ptr</code>已经析构，但是<code>std::weak_ptr</code>依然存在并会指向到控制块（弱计数大于零），所以控制块会持续存在，包含它的内存也会持续存在。这么一来，假设对象的尺寸很大，且最后一个<code>std::shared_ptr</code>和<code>std::weak_ptr</code>析构之间的时间间隔不能忽略，在对象的析构和内存的释放之间就会产生延迟。<br>如果是使用new表达式，则对象内存可以在最后一个指向它的<code>std::shared_ptr</code>析构时就释放。而使用new表达式时，要避开之前提到的异常安全问题。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw, <span class="keyword">int</span> priority)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cusDel</span><span class="params">(Widget *ptr)</span></span>;  <span class="comment">// 自定义析构器</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, cusDel)</span></span>;</span><br><span class="line">processWidget(<span class="built_in">std</span>::move(spw), computePriority());  <span class="comment">// std::move 右值传递，节省开销</span></span><br></pre></td></tr></table></figure>
<h2 id="使用Pimpl习惯用法"><a href="#使用Pimpl习惯用法" class="headerlink" title="使用Pimpl习惯用法"></a>使用Pimpl习惯用法</h2>Pimpl习惯用法是一种可以在类实现和类使用之间减少编译依赖性的方法。<br>对采用<code>std::unique_ptr</code>来实现的Pimpl指针，需在头文件中声明特种成员函数，但在实现文件中实现他们，即使默认函数实现有着正确的行为，必须要这样做，这对<code>std::shared_ptr</code>并不适用。</li>
</ol>
<h1 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h1><hr>
<p>右值引用是把移动语义和完美转发两种语言特性粘合的底层语言机制。一开始看山是山，看水是水；了解的越多，看山不是山，看水不是水，最后山还是山，水还是水。</p>
<h2 id="std-move和std-forward"><a href="#std-move和std-forward" class="headerlink" title="std::move和std::forward"></a>std::move和std::forward</h2><p>这两者在运行期都无所作为，不会生成任何可执行代码。<code>std::move</code>并不进行任何移动，而是把实参强制转换成右值。在一个对象上实施<code>std::move</code>是告诉编译器这个对象具备可移动的属性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11中std::move的示例实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;  <span class="comment">// 确保返回右值引用</span></span><br><span class="line">move(T&amp;&amp; param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType =</span><br><span class="line">        <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++14中std::move的示例实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>移动操作不能违反维持常量正确性的原则，所以不允许常量对象进行移动。如果想取得某个对象执行移动操作的能力，不要将其声明为常量。考虑以下情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; rhs);  <span class="comment">// 无法std::move</span></span><br><span class="line">    <span class="built_in">string</span>(<span class="built_in">string</span>&amp;&amp; rhs);       <span class="comment">// 只能接受非常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>std::move</code>无条件将实参强制转换为右值，而std::forward则仅在某个特定条件满足时才执行同一个强制转换。<br><code>std::forward</code>最常见的一个使用场景是某个函数模板有万能引用的形参，随后将其传递给另一个函数。因为一切函数形参皆左值，所以为了避免这种结果，就需要一种机制，左值保持不变，传递左值；右值传递右值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">const</span> Widget&amp; lvalArg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rvalArg)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span> </span>&#123; process(<span class="built_in">std</span>::forward&lt;T&gt;(param)); &#125;</span><br></pre></td></tr></table></figure><br>这里，<code>std::forward</code>可以分辨出param是通过左值还是右值完成初始化的，该信息被编码到模板形参T中。详细参见“引用折叠”。<br><code>std::move</code>只取用一个实参，而<code>std::forward</code>需要同时取用类型+实参，两者的含义也有很大的不同。</p>
<h2 id="万能引用和右值引用"><a href="#万能引用和右值引用" class="headerlink" title="万能引用和右值引用"></a>万能引用和右值引用</h2><p>万能引用可以绑定到右值引用、左值引用、const、volatile，一般指出现在函数模板的形参和auto声明，也就是说需要涉及到类型推导才行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 万用引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class... Args&gt; <span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> timeFuncInvocation =</span><br><span class="line">    [](<span class="keyword">auto</span>&amp;&amp; func, <span class="keyword">auto</span>&amp;&amp;... params)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(func)&gt;(func)(           <span class="comment">// func</span></span><br><span class="line">        <span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)..  <span class="comment">// params</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f</span><span class="params">(cosnt T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="对右值引用实施std-move，对万能引用实施std-forward"><a href="#对右值引用实施std-move，对万能引用实施std-forward" class="headerlink" title="对右值引用实施std::move，对万能引用实施std::forward"></a>对右值引用实施std::move，对万能引用实施std::forward</h2><p>右值引用仅会绑定到可供移动的对象上，所以需要<code>std::move</code>把对象转换为右值。万能引用只有在使用右值初始化才会是右值，对应<code>std::forward</code>。如果对万能引用施加<code>std::move</code>就可能有问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;name = <span class="built_in">std</span>::move(newName);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">w.setName(n);  <span class="comment">// n的值移入了w，n的值未知</span></span><br></pre></td></tr></table></figure><br>如果不使用万能引用，分别写成两个函数可能会遇到效率问题。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; newName)</span></span>&#123; name = newName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; newName)</span></span>&#123; name = <span class="built_in">std</span>::move(newName); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">w.setName(<span class="string">&quot;Adela Novak&quot;</span>); <span class="comment">// 对这个调用，重载版本会比万能引用多创建一次临时对象用来传参</span></span><br></pre></td></tr></table></figure><br>分成函数写，当参数变多甚至可变形参时，就显得不太现实。因此，万能引用+<code>std::forward</code>是解决问题的唯一方法。<br>有些情况，在单一函数内一个对象会不止一次地绑定到右值引用或万能引用，这时仅在最后一次使用引用即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对矩阵加法</span></span><br><span class="line">Matrix opeartor+(MAtrix&amp;&amp; lhs, <span class="keyword">const</span> Matrix&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(lhs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 约分</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Function <span class="title">reduceAndCopy</span><span class="params">(T&amp;&amp; frac)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    frac.reduce();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;T&gt;(frac);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>RVO（return value optimization）<br>编译器对函数返回值自带优化，需要满足两个条件：</p>
<ol>
<li>局部对象类型和函数返回值类型相同。</li>
<li>返回的就是局部对象本身。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里返回的不是局部对象，而是局部对象的引用，因此编译器无法实施<code>RVO</code>，但编译器不选择执行<code>RVO</code>的时候，返回对象必须作为右值处理。即要么发生复制忽略，要么<code>std::move</code>被隐式实施于返回的局部对象。</li>
</ol>
<h2 id="万能引用的重载"><a href="#万能引用的重载" class="headerlink" title="万能引用的重载"></a>万能引用的重载</h2><p>一旦万能引用作为重载候选，它就会吸走大批的实参类型，完美转发构造函数尤其严重，因为对于非常量的左值类型，它们一般都会形成相对于复制构造函数的更加匹配，并且还会劫持派生类中对基类的复制和移动构造函数的调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;tyepname T&gt; <span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(T&amp;&amp; n)</span>: <span class="title">name</span><span class="params">(<span class="built_in">std</span>::forward&lt;T&gt;(n))</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialPerson</span>:</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 都是调用基类的完美转发构造函数</span></span><br><span class="line">    SpecialPerson(<span class="keyword">const</span> SpecialPerson&amp; rhs): Person(rhs) &#123;...&#125;</span><br><span class="line">    SpecialPerson(SpecialPerson&amp;&amp; rhs): Person(<span class="built_in">std</span>::move(rhs) &#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>为了解决这些问题，要么就直接弃用重载，要么通过区分传递<code>const T&amp;</code>，要么通过传值操作（把按引用传递换成按值传递，尽管这反直觉，当知道肯定需要复制形参时，考虑按值传递）</p>
<p>兼顾特性的做法是标签分派，以下是示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    logAndAddImpl(</span><br><span class="line">        <span class="built_in">std</span>::forward&lt;T&gt;(name),</span><br><span class="line">        <span class="built_in">std</span>::is_intergal&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, <span class="built_in">std</span>::false_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.emplace(<span class="built_in">std</span>::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">nameFormIdx</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">std</span>::true_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    logAndAdd(nameFromIdx(idx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>标签分派的思想是这样的，如果万能引用仅是形参列表的一部分，列表中还有其他非万能引用的形参，那么只要这个非万能引用不匹配，这个重载函数就不会匹配。<br>通用的做法是重写万能引用的函数，函数内部再委托给另外两个函数，比如上面用<code>std::is_intergal</code>区分整型or非整型，因为推导以及引用类型int&amp;不是int，所以还要加上<code>std::remove_reference</code>。然后<code>std::is_intergal</code>会得到<code>std::true_type</code>和<code>std::false_type</code>两种结果。<br>true和false都是运行期的值，这里我们需要利用的是重载决议（处于编译期）来选择正确的重载版本，所以需要<code>std::true_type</code>和<code>std::false_type</code>。这就是所谓的“<code>标签</code>”。<br>标签分派能够发挥作用的关键在于，存在一个单版本函数作为API，该函数会把待完成的任务分派到实现函数，创建无重载的分派函数并不难。但是这解决不了劫持派生类中对基类的复制和移动构造函数的调用的问题。</p>
<p><code>std::enable_if</code>可以强制编译器禁用模板，默认时所有的模板都是启用的，但是施加了<code>std::enable_if</code>的模板只会在满足了<code>std::enable_if</code>指定的条件才会启用，更深入的可以参考：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMTMxNDcwOA==">C++SHINAE机制 — 知乎<i class="fa fa-external-link-alt"></i></span><br>以下是一个示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;</span><br><span class="line">        !<span class="built_in">std</span>::is_base_of&lt;Person, <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">        &amp;&amp;</span><br><span class="line">        <span class="built_in">std</span>::is_integral&lt;<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">        &gt;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> Person(T&amp;&amp; n): name(<span class="built_in">std</span>::forward&lt;T&gt;(n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static_assert</span>(</span><br><span class="line">            <span class="built_in">std</span>::is_constructible&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, T&gt;::value,</span><br><span class="line">            <span class="string">&quot;Parameter n can&#x27;t be used to construct a std::string&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里想指定的条件是T不是Person类型时才启用这个模板函数，通过<code>!std::is_same&lt;Person,T&gt;::value</code>，深入思考，在得到T时，要移除它是否为一个引用（这个简单），也要移除它是否带有const或volatile，这时需要使用<code>std::decay&lt;T&gt;::type</code>或者<code>std::decay_t&lt;T&gt;(c++14)</code>，这么一来就成了<code>!std::is_same&lt;Person,typename std::decay&lt;T&gt;::type&gt;::value</code>。<br>在最开始的例子，派生类会给基类的构造函数传递对象，因为派生类和基类不同，所以这里的构造函数仍会被启用。<code>std::is_same</code>要换成<code>std::is_base_of</code>，来判断是否类型有继承。</p>
<p>万能引用转发次数越多，某些地方出错时给出的错误信息就越难懂。可以通过写一些断言来缓解这个问题。参考：<span class="exturl" data-url="aHR0cHM6Ly96aC5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2hlYWRlci90eXBlX3RyYWl0cw==">type_traits<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>当初始化形参为万能引用时，实参传递给函数模板时，推导出来的模板形参会将实参时左值还是右值的信息编码到结果类型中。<br>如果传递的实参是个左值，T推到结果为左值引用。<br>如果传递的实参是个右值，T推导结果是个非引用。<br>因为C++禁用引用的引用，所以折叠。</p>
<blockquote>
<p>A&amp; &amp; 变成 A&amp;<br>A&amp; &amp;&amp; 变成 A&amp;<br>A&amp;&amp; &amp; 变成 A&amp;<br>A&amp;&amp; &amp;&amp; 变成 A&amp;&amp;</p>
</blockquote>
<p>引用折叠会在四种语境中发生：模板实例化、auto类型推导、创建和运用typedef和别名声明、decltype。<br>万能引用并不是新的引用，而是满足条件的右值引用：</p>
<ol>
<li>类型推导会区别左值和右值。</li>
<li>会发生引用折叠。</li>
</ol>
<h2 id="假定移动操作不存在、成本高、未使用"><a href="#假定移动操作不存在、成本高、未使用" class="headerlink" title="假定移动操作不存在、成本高、未使用"></a>假定移动操作不存在、成本高、未使用</h2><p>C++98的代码原封不动地在C++11编译器上编译，也会有性能优化。但是有很多场景移动操作并不高效。在这几个场景，C++11移动语义不会带来任何好处：</p>
<ol>
<li>std::array是STL数组，数据直接存在对象上而不是堆上。</li>
<li>std::string有SSO（small string optimization），即小型字符串会储存在缓存区而不是堆上。</li>
<li>一些看似万无一失的移动场景，没有加上noexcept的话，编译器会强制调用复制。要求移动不可发射异常，必须加上noexcept声明。</li>
<li>没有移动操作，移动请求就变成了复制请求。</li>
<li>移动还不如复制更快。</li>
<li>原对象是个左值，除了极少数例外，只有右值可以移动。</li>
</ol>
<h2 id="完美转发的失败情况"><a href="#完美转发的失败情况" class="headerlink" title="完美转发的失败情况"></a>完美转发的失败情况</h2><p>完美转发的失败，是源自模板推导的失败，或者推导结果错误。会导致完美转发失败的实参种类有<code>大括号初始化物</code>、<code>以0或NULL表达的空指针</code>、<code>仅有声明的整型static const成员变量、模板或重载函数名字</code>、以及<code>位域</code>。</p>
<p>完美转发不仅转发对象、还会转发类型、左值右值、是否嗲有const、volatile。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;<span class="function"><span class="keyword">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;Ts&gt;(param)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>常规情况下，编译器先得到调用端的实参类型，再得到f所声明的形参类型，比较两者是否兼容，（之后通过隐式类型转换）来调用成功。而经由完美转发，编译器采用推导的手法得到调用端的实参类型与所声明的形参类型比较，会在以下任何一种情况成立时失败：</p>
<ol>
<li>编译器无法为一个或多个fwd的形参推导出结果。</li>
<li>编译器为一个或多个fwd的形参推导出了“错误”的结果。</li>
</ol>
<p><code>大括号初始化物</code>的问题在于向未声明<code>std::initializer_list</code>类型的函数模板传递了大括号，叫作“非推导语境”，所以会被编译器禁止。但是可以先用<code>auto</code>推导，然后传递给完美转发函数。</p>
<p>若尝试把0或NULL传给模板，类型推导的结果就是整型，传递<code>nullptr</code>即可。</p>
<p><code>static cosnt</code>成员变量仅需声明，不必保留内存。一般调用直接当作常数处理，完美转发会失败，因为隐含了取地址，毕竟引用和指针实现类似。</p>
<p>重载的函数名字和模板名字，因为没有任何关于类型的信息，编译器不知道应该传递哪个版本。</p>
<p>位域<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IPv4Header</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">uint32_t</span> version:<span class="number">4</span>,</span><br><span class="line">                  IHL:<span class="number">4</span>,</span><br><span class="line">                  DSCP:<span class="number">6</span>,</span><br><span class="line">                  ECN:<span class="number">2</span>,</span><br><span class="line">                  totalLength:<span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可以这么做</span></span><br><span class="line">IPv4Header h;</span><br><span class="line"><span class="keyword">auto</span> length = <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">uint16_t</span>&gt;(h.totalLength);</span><br><span class="line">fwd(length);</span><br></pre></td></tr></table></figure><br>C++标准禁止非const引用绑定到位域。位域是由机器字的若干任意部分组成的，没办法对其直接去地址。指针指向的最小实体是一个字节。</p>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><hr>
<p>lambda是表达式的一种，闭包是lambda式创建的运行期对象，根据不同的捕获模式，闭包会持有数据的副本或引用。<br>闭包类就是实例化闭包的类，每个lambda都会触发编译器生成独一无二的闭包类，而闭包中的语句会变成成员函数可执行语句。</p>
<h2 id="避免默认捕获模式"><a href="#避免默认捕获模式" class="headerlink" title="避免默认捕获模式"></a>避免默认捕获模式</h2><p>C++11有两种默认捕获方式：按引用或按值。</p>
<p>按引用的默认捕获模式可能会导致空悬引用，一旦lambda式所创建的闭包越过了生存周期，引用就会空悬。该局部变量或形参<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> divisor = computeDivisor();</span><br><span class="line">filters.emplace_back([&amp;divisor](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125; );</span><br></pre></td></tr></table></figure><br>闭包会被立即使用（例如STL算法）并且不会被复制的场景，引用比原对象的生命期更长就不存在风险。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">std</span>::all_of(<span class="built_in">std</span>::begin(container), <span class="built_in">std</span>::end(container),</span><br><span class="line">    [&amp;](<span class="keyword">const</span> ContElemT&amp; value)&#123;<span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// c++14 已经可以用auto了 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">std</span>::all_of(<span class="built_in">std</span>::begin(container), <span class="built_in">std</span>::end(container),</span><br><span class="line">    [&amp;](<span class="keyword">auto</span>&amp; value)&#123;<span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;))</span><br></pre></td></tr></table></figure><br>另一种是按值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filters.emplace_back([=](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125; );</span><br></pre></td></tr></table></figure><br>按值并不能避免空悬，问题在于经过复制，闭包中得到是副本，如果是指针什么的还是可能空悬的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFilter</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        filters.emplace_back([=](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125; );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> divisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>lambda式只能捕获作用域内可见的非静态局部变量和形参，以上代码无法编译通过。这里，lambda捕获的其实是this指针，lambda闭包的存活与它含有其this指针副本的对象的生命期式绑定的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>&gt;&gt;;</span><br><span class="line">FilterContainer filters;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pw = <span class="built_in">std</span>::make_unique&lt;Widget&gt;();</span><br><span class="line">    pw-&gt;addFilter();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> divisorCopy = divisor;</span><br><span class="line">    filters.emplace_back([divisorCopy](<span class="keyword">int</span> value)&#123;<span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>;&#125;);</span><br><span class="line">    filters.emplace_back([=](<span class="keyword">int</span> value)&#123;<span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>;&#125;); <span class="comment">// 这样也行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c++14，lambda广义捕获</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> divisorCopy = divisor;</span><br><span class="line">    filters.emplace_back(</span><br><span class="line">        [divisor = divisor](<span class="keyword">int</span> value)       <span class="comment">// 将divisor复制入闭包</span></span><br><span class="line">        &#123;<span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用默认值捕获另一缺点是，给人感觉lambda与闭包外数据绝缘，但其实并不是。除了依赖作用域内可见的非静态局部变量和形参，其实还会依赖静态存储期对象，这样的对象定义在全局或命名空间作用域中，又或在类中、在函数中、在文件中以static声明，这些玩意儿都不能被捕获。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> calc1 = computeSomeValue1();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> calc2 = computeSomeValue2();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> divisor = computeDivisor(calc1, calc2);</span><br><span class="line">    filters.emplace_back(</span><br><span class="line">        [=](<span class="keyword">int</span> value)                    <span class="comment">// 没有捕获到任何东西，看上去是按值，其实是按引用</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;  <span class="comment">// 指涉到static对象</span></span><br><span class="line">    );</span><br><span class="line">    ++divisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用初始化捕获将对象移入闭包"><a href="#使用初始化捕获将对象移入闭包" class="headerlink" title="使用初始化捕获将对象移入闭包"></a>使用初始化捕获将对象移入闭包</h2><p>C++11没有办法移动对象到闭包，C++14则有云泥之别，即通过初始化捕获来弥补C++11移动捕获的缺失。这样就可以在lambda使用只移对象以及大部分的标准库（移动廉价、复制昂贵）。<br>使用初始化捕获，可以得到机会指定：</p>
<ol>
<li>由lambda生成的闭包类中的成员变量的名字。</li>
<li>一个表达式，用以初始化该成员变量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidated</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isArchived</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> pw = <span class="built_in">std</span>::make_unique&lt;Widget&gt;();</span><br><span class="line"><span class="keyword">auto</span> func = [pw = <span class="built_in">std</span>::move(pw)]       <span class="comment">// &quot;=&quot;左右，即初始化捕获</span></span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;isValidated()</span><br><span class="line">                  &amp;&amp; pw-&gt;isArchived(); &#125;;</span><br><span class="line"><span class="comment">// 这样也可以</span></span><br><span class="line"><span class="keyword">auto</span> func = [pw = <span class="built_in">std</span>::make_unique&lt;Widget&gt;()] </span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;isValidated()</span><br><span class="line">                  &amp;&amp; pw-&gt;isArchived(); &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上，初始化捕获也就是广义lambda捕获（<code>generalized lambda capture</code>）。<br>假如编译器只支持到C++11，多敲键盘也能达到目的，以下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsValAndArch</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">isValAndArch</span><span class="params">(DataType&amp;&amp; ptr)</span>: <span class="title">pw</span><span class="params">(<span class="built_in">std</span>::move(ptr))</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchisved(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType pw;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> func = IsValAndArch(<span class="built_in">std</span>::make_unique&lt;Widget&gt;());</span><br></pre></td></tr></table></figure><br>如果非要使用lambda式，按移动捕获可以在C++11中模拟做到：</p>
<ol>
<li>把需要捕获的对象移动到std::bind产生的函数对象中。</li>
<li>给到lambda式一个指向欲“捕获”的对象的引用。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++14</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; data;</span><br><span class="line"><span class="keyword">auto</span> func = [data = <span class="built_in">std</span>::move(data)]&#123; <span class="comment">/*对数据加以运用*/</span> &#125;;</span><br><span class="line"><span class="comment">// c++11</span></span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">std</span>::bind(</span><br><span class="line">    [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; data)</span><br><span class="line">    &#123; <span class="comment">/*对数据加以运用*/</span> &#125;,</span><br><span class="line">    <span class="built_in">std</span>::move(data)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>和lambda式类似，<code>std::bind</code>返回函数对象并成为绑定对象（bind ojbect）。<code>std::bind</code>的第一个实参是一个可调用对象，接下来所有的实参都表示传给该对象的值。绑定对象含有传递给<code>std::bind</code>所有实参的副本，对于每个左值实参都会复制，每个右值实参都会移动。<br>默认情况下，lambda生成的闭包类中的operator()会带有const，结果闭包里的所有成员变量在lambda式的函数体内都会带有const。但是绑定对象里移动构造得到的data副本并不带有const，所以为了防止该data副本在lambda内被意外修改，形参需要为const T。但如果lambda声明带有mutable，闭包里的operator()就不会带const了，相应的形参应该略去const：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = <span class="built_in">std</span>::bind(</span><br><span class="line">    [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; data) <span class="keyword">mutable</span></span><br><span class="line">    &#123; <span class="comment">/*对数据加以运用*/</span> &#125;,</span><br><span class="line">    <span class="built_in">std</span>::move(data)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>使用std::bind模拟移动捕获，再举一例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++14</span></span><br><span class="line"><span class="keyword">auto</span> func = [pw = <span class="built_in">std</span>::make_unique&lt;Widget&gt;()]</span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived(); &#125;</span><br><span class="line"><span class="comment">// c++11</span></span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">std</span>::bind([](<span class="keyword">const</span> <span class="built_in">std</span>::unqiue_ptr&lt;Widget&gt;&amp; pw)</span><br><span class="line">                      &#123; <span class="keyword">return</span> pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived(); &#125;,</span><br><span class="line">                      <span class="built_in">std</span>::make_unique&lt;Widget&gt;()</span><br><span class="line">                     );</span><br></pre></td></tr></table></figure></p>
<h2 id="对auto-amp-amp-形参使用dectltype"><a href="#对auto-amp-amp-形参使用dectltype" class="headerlink" title="对auto&amp;&amp;形参使用dectltype"></a>对auto&amp;&amp;形参使用dectltype</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x)&#123; <span class="keyword">return</span> func(normalize(x)); &#125;;</span><br><span class="line"><span class="comment">// 对应的闭包类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeCompilerGeneratedClassName</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> func(normalize(x)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里应该把x完美转发给normalize()，但是泛型lambda式却没有可用的T可以用。改进后的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> func(normalize(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(param)&gt;(param)));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp;... params)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> func(normalize(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aC5jcHByZWZlcmVuY2UuY29tL3cvY3BwL3V0aWxpdHkvZnVuY3Rpb25hbC9iaW5k">std::bind<i class="fa fa-external-link-alt"></i></span>是C++98中<code>std::bind1st</code>和<code>std::bind2nd</code>的后继特性。作为非标准特性，在05年就成为标准库的组成部分（那时标准委员会刚接受了<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQyUyQiUyQl9UZWNobmljYWxfUmVwb3J0XzE=">C++ Technical Report 1 (TR1)文档<i class="fa fa-external-link-alt"></i></span>）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Time = <span class="built_in">std</span>::chrono::steady_clock::time_point;</span><br><span class="line">emum <span class="class"><span class="keyword">class</span> <span class="title">Sound</span> &#123;</span>Beep, Siren, Whisstle&#125;;</span><br><span class="line"><span class="keyword">using</span> Duration = <span class="built_in">std</span>::chrono::steady_clock::duration;</span><br><span class="line"><span class="comment">// 在时刻t，发出声音s，持续d</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d)</span></span>;</span><br><span class="line"><span class="comment">// lambda</span></span><br><span class="line"><span class="keyword">auto</span> setSoundL = [](Sound s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br><span class="line">    setAlarm(steady_clock::now() + hours(<span class="number">1</span>),  <span class="comment">// 一小时后</span></span><br><span class="line">             s,                               <span class="comment">// 发出声音</span></span><br><span class="line">             seconds(<span class="number">30</span>));                    <span class="comment">// 响30秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// c++14提供了ms,s,h</span></span><br><span class="line"><span class="keyword">auto</span> setSoundL = [](Sound s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br><span class="line">    setAlarm(steady_clock::now() + <span class="number">1</span>h, s, <span class="number">30</span>s);                 </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// std::bind</span></span><br><span class="line"><span class="keyword">using</span> namepsace <span class="built_in">std</span>::chrono;</span><br><span class="line"><span class="keyword">using</span> namepsace <span class="built_in">std</span>::literals;</span><br><span class="line"><span class="keyword">using</span> namepsace <span class="built_in">std</span>::placeholders;</span><br><span class="line"><span class="keyword">auto</span> setSoundB = <span class="built_in">std</span>::bind(setAlarm, steady_clock::now() + <span class="number">1</span>h, _1, <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><br>使用<code>std::bind</code>存在一些问题，我们想要的是在setAlarm被调用的时刻之后1小时报警，但是这里是调用<code>std::bind</code>一小时后报警，为了解决这个问题需要延迟表达式的评估求值调用setAlarm的时刻。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++14: 标准运算符的模板实参大多数情况下可以省略不写</span></span><br><span class="line"><span class="keyword">auto</span> setSoundB = <span class="built_in">std</span>::bind(setAlarm, </span><br><span class="line">                           <span class="built_in">std</span>::bind(<span class="built_in">std</span>::plus&lt;&gt;(), steady_clock::now(), <span class="number">1</span>h),</span><br><span class="line">                           _1, <span class="number">30</span>s);</span><br><span class="line"><span class="comment">// c++11 还不支持这样的特性</span></span><br><span class="line"><span class="keyword">auto</span> setSoundB = <span class="built_in">std</span>::bind(setAlarm, </span><br><span class="line">                           <span class="built_in">std</span>::bind(<span class="built_in">std</span>::plus&lt;steady_clock::time_point&gt;(), </span><br><span class="line">                           steady_clock::now(), <span class="number">1</span>h),</span><br><span class="line">                           _1, <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><br>一旦函数进行重载，新的问题又会出现，之前的lambda式没有问题，但是<code>std::bind</code>会无法编译通过。为了使得<code>std::bind</code>的调用能够通过编译，需要强制转换类型到合适的函数指针。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SetAlarm3ParamType = <span class="keyword">void</span>(*)(Time t, Sound s, Duration d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB = <span class="built_in">std</span>::bind(<span class="keyword">static_cast</span>&lt;SetAlarm3ParamType&gt;(setAlarm),</span><br><span class="line">                           <span class="built_in">std</span>::bind(<span class="built_in">std</span>::plus&lt;steady_clock::time_point&gt;(), </span><br><span class="line">                           steady_clock::now()</span><br><span class="line">                           <span class="number">1</span>h),</span><br><span class="line">                           _1, <span class="number">30</span>s );</span><br></pre></td></tr></table></figure><br>这样又带出来lambda式和<code>std::bind</code>的另一个不同之处，lambda式式常规的函数唤起方式，编译器可以用惯用手法将其内联。可是，<code>std::bind</code>的调用传递了一个函数指针，几乎无法内联。此外，随着想做的事情越来越复杂，使用lambda式的好处会扩大。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> betweenL = [lowVal, highVal](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val)</span><br><span class="line">                &#123; <span class="keyword">return</span> lowVal &lt;= val &amp;&amp; val &lt;= highVal; &#125;;</span><br><span class="line"><span class="comment">// std::bind</span></span><br><span class="line"><span class="keyword">auto</span> betweenB = </span><br><span class="line">    <span class="built_in">std</span>::bind(<span class="built_in">std</span>::logical_and&lt;<span class="keyword">bool</span>&gt;(),</span><br><span class="line">              <span class="built_in">std</span>::bind(<span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;(), lowVal, <span class="built_in">std</span>::placeholders::_1),</span><br><span class="line">              <span class="built_in">std</span>::bind(<span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;(), <span class="built_in">std</span>::placeholders::_1, highVal));</span><br></pre></td></tr></table></figure><br><code>std::bind</code>总是按值复制，不过可以通过<code>std::ref()</code>达成按引用传递，lambda式要更直观一些。在C++11中，仍需要<code>std::bind</code>的场景：</p>
<ol>
<li>移动捕获。C++11的lambda式不能移动捕获，可以通过std::bind和lambda模拟移动捕获。</li>
<li>多态函数对象。因为绑定对象的函数调用运算符利用了完美转发，呀就可以接受任何类型的实参。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolyWidget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用std::bind绑定PolyWidget对象</span></span><br><span class="line">PolyWidget pw;</span><br><span class="line"><span class="keyword">auto</span> boundPW = <span class="built_in">std</span>::bind(pw, _1);</span><br></pre></td></tr></table></figure>
这样，boundPW就可以通过任意类型的实参加以调用，C++11 lambda做不到这一点，但是C++14可以。因此，std::bind在C++14已经没啥用处了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> boundPW = [pw](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; param) &#123; pw(param); &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="并发API"><a href="#并发API" class="headerlink" title="并发API"></a>并发API</h1><h2 id="基于任务的程序设计"><a href="#基于任务的程序设计" class="headerlink" title="基于任务的程序设计"></a>基于任务的程序设计</h2></li>
</ol>
<h2 id="异步，指定std-launch-async"><a href="#异步，指定std-launch-async" class="headerlink" title="异步，指定std::launch::async"></a>异步，指定std::launch::async</h2><h2 id="使std-thread在所有路径不可联结"><a href="#使std-thread在所有路径不可联结" class="headerlink" title="使std::thread在所有路径不可联结"></a>使std::thread在所有路径不可联结</h2><h2 id="关注线程句柄的析构函数"><a href="#关注线程句柄的析构函数" class="headerlink" title="关注线程句柄的析构函数"></a>关注线程句柄的析构函数</h2><h2 id="针对一次性时间通信使用以void为模板"><a href="#针对一次性时间通信使用以void为模板" class="headerlink" title="针对一次性时间通信使用以void为模板"></a>针对一次性时间通信使用以void为模板</h2><h2 id="并发std-atomic，特种内存volatile"><a href="#并发std-atomic，特种内存volatile" class="headerlink" title="并发std::atomic，特种内存volatile"></a>并发std::atomic，特种内存volatile</h2>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 读书笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/03.%E6%97%8B%E8%BD%AC%E8%A1%A8%E7%A4%BA%E6%B3%95/" rel="prev" title="旋转表示法">
                  <i class="fa fa-chevron-left"></i> 旋转表示法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/06.openmp/" rel="next" title="OpenMP">
                  OpenMP <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fab fa-github"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朋克李PunkLi</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">163k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:28</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  

<script src="/js/local-search.js"></script>






  





  


</body>
</html>
